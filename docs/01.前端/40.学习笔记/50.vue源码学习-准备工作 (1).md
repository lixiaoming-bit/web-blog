---
title: vue源码学习-准备工作 (1)
date: 2020-06-13 17:59:14
permalink: /pages/677e63
categories: 
  - 前端
  - 学习笔记
tags: 
  - 
---
# Vue源码学习

## Flow
1. 解释：静态类型检查工具
2. 安装：npm i flow-bin
3. 使用：flow init => 会生成一个flowconfig配置文件，需要在使用的js中添加 **@flow**

---

我们在进行js编译的时候，由于js是动态弱类型语言，其特点就是灵活性很强，我们需要在编译之前就将其字段的类型进行定义（记录）防止在隐式转换的时候该改变了类型，从而使得我们的在传递值得过程中出现错误，使用flow的目的就是尽可能的防止这种错误的出现，同时配合ESlint进行语法风格校验。
这种规范其实在typescript中也有用到，那么在2020年会迎来整体3.*+的变动，到时候我们的编译方式也会从使用原生js向ts过渡。

---

## vue的目录结构

![vue目录结构](http://qiniu.bilent.top/blog-20191212131028.png)

1. compiler
  Vue.js编译相关的源码，将模板解析成ast语法树并优化，生成代码等功能。编译的工作可以在构建的时候借助相关第三方插件，例如：webpack,vue-loader等等，可以在运行的时候进行构建Vue.js。当然，构建是一项耗费性功能的工作，一般是离线编译。

2. core
  Vue.js的核心源码，包括内置组件，全局API封装，Vue实例化，观察者，虚拟DOM，工具函数等等

3. platform
  Vue.js运行平台，默认的是web和weex(类似与React-Native)的移动端框架，这里两个环境表示了Vue的入口，这样打包成的文件就可以在相对应的平台上进行

4. server
  现在Vue.js已经支持服务端渲染，所有服务端渲染相关的逻辑都是在这个目录下。同时这部分代码是在Node.js上面运行的，其实服务端渲染就是从服务端返回整个页面渲染需要的代码，我们在使用服务端渲染的目的就是有利于SEO，比较熟悉的ssr渲染方式有使用nuxt.js来渲染页面.

5. sfc
  通常我们在开发Vue.js的时候都需要借助webpack来进行构建，然后输出一个.vue的单文件编写组件，这个目录下的代码逻辑就是将.vue的文件内容解析成一个JS对象

6. shared
  Vue.js会定义一些工具方法，这些定义的工具方法都是会被浏览器的Vue.js和服务端的Vue.js所共享

---

从这里我们可以看出来，Vue.js的功能模块代码拆分的非常清楚。

## Vue构建
Vue 的构建基于RollUp，相对于webpack，这个更轻量，更专向于js的构建。
在package.json中的script中进行执行，将不同版本的是vue.js打包到dist文件下,打包的命令如下：
```json
{
  "script": {
    "build": "node scripts/build.js",
    "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
    "build:weex": "npm run build --weex"
  }
}
```
当我们执行
> npm run build
具体的构建过程：
1. 在scripts/build.js中，打开入口js文件

```javascript
let builds = require('./config').getAllBuilds()
// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}
build(builds)  
```
先从配置文件读取配置，在通过命令行参数对构建的配置进行过滤，这样可以构建不同用途的Vue.js。

2. 在scripts/config.js中我们查看配置文件

```javascript
const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.js'),
    format: 'cjs',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-cjs': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.js'),
    format: 'cjs',
    alias: { he: './entity-decoder' },
    banner
},
  // Runtime only (ES Modules). Used by bundlers that support ES Modules,
  // e.g. Rollup & Webpack 2
  'web-runtime-esm': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.esm.js'),
    format: 'es',
    banner
  },
  // Runtime+compiler CommonJS build (ES Modules)
  'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
  },
  // runtime-only build (Browser)
  'web-runtime-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler production build  (Browser)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // ...
}
```
对于每一个配置，遵循rollup构建规则的，`entry`是入口js文件的地址，`dest`是构建后的js文件地址。`formate`表示的是构建的格式，其中`cjs`表示的是构建出来的文件遵循`CommonJS`规范，`es`表示构建出来的问题遵循`ES Moudle`规范，`umd`表示构建出来的文件遵循`UMD`规范。

通过`path.resolve`进行路径的解析，他们最终都会经过`RollUp`的进行构建打包，最终会在`dist`目录下生成不同版本功能的`Vue.js`

---

**Runtime Only VS Runtime+Compiler**

我们使用`Vue-cli | vue/cli`初始化构建我们项目的时候通常会询问我们这两个关键词。
1. Runtime Only
使用此版本的`Vue.js`，通常需要借助`webpack`的`Vue-loader`工具把`.vue`的文件编译成`Javascript`，因为是在编译的阶段进行的，所以他只包含运行时的`Vue.js`代码，因此代码的体积会更轻量。
2. Runtime+Compiler
我们没有对代码进行预编译，但是又使用了`Vue`的`template`属性并传入一个字符串，则需要我们在代码进行编译的时候

```Vue
// 需要编译器的版本
new Vue({
  template: '<div>{{ hi }}</div>'
})

// 这种情况不需要
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```
在`Vue2.0`中，最终的渲染方式都是通过`render`函数，如果写`template`属性，则需要编译成`render`函数，那么这个编译的过程会发生在进行的时候，所以需要带有编译器的版本，很显然，这个编译过程对性能会有一定损耗，所以通常我们更推荐使用 `Runtime-Only` 的 `Vue.js`。

当我们使用`compiler`的版本的`Vue.js`，`webpack`会在`webpack.base.conf.js`中的`resolve`下生成一个人`alias`,将`vue`映射成

```javascript
resolve: {
  alias: {
    'vue': resolve('node_modules/vue/dist/vue.esm.js')
  }
}
```

---

## 从入口开始
在`web`应用下，我们来分析`Runtime+Compiler`构建出来的`Vue.js`，它的入口文件是`src/platforms/web/entry-runtime-with-compiler.js`

```javascript
/* @flow */

import config from 'core/config'
import { warn, cached } from 'core/util/index'
import { mark, measure } from 'core/util/perf'

import Vue from './runtime/index'
import { query } from './util/index'
import { compileToFunctions } from './compiler/index'
import { shouldDecodeNewlines, shouldDecodeNewlinesForHref } from './util/compat'

const idToTemplate = cached(id => {
  const el = query(id)
  return el && el.innerHTML
})

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el: Element): string {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    const container = document.createElement('div')
    container.appendChild(el.cloneNode(true))
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions

export default Vue
```
当我们执行`import Vue from 'vue'`的时候，就是从这个入口文件中执行初始化Vue

---

**Vue的入口**  
在引入部分，我们逐级向上查找就能够看见`Vue`的定义来源：它定义在 `src/platforms/web/runtime/index.js` 中,`import Vue from './runtime/index`

```javascript
import Vue from 'core/index'
import config from 'core/config'
import { extend, noop } from 'shared/util'
import { mountComponent } from 'core/instance/lifecycle'
import { devtools, inBrowser, isChrome } from 'core/util/index'

import {
  query,
  mustUseProp,
  isReservedTag,
  isReservedAttr,
  getTagNamespace,
  isUnknownElement
} from 'web/util/index'

import { patch } from './patch'
import platformDirectives from './directives/index'
import platformComponents from './components/index'

// install platform specific utils
Vue.config.mustUseProp = mustUseProp
Vue.config.isReservedTag = isReservedTag
Vue.config.isReservedAttr = isReservedAttr
Vue.config.getTagNamespace = getTagNamespace
Vue.config.isUnknownElement = isUnknownElement

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

// ...

export default Vue
```

这里面可以看见`import Vue from 'core/index`，后面的逻辑都是对Vue这个对象的扩展。真正初始化Vue的地方，是在`src/core/index`中：

```javascript
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
```
这里面这两处
> import Vue from './instance/index'
> initGlobalAPI(Vue)

在`src/core/instance/index.js`中，有如下对于Vue的定义：
```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```
在这里，我们最终看到了对Vue的定义，它实际上就是一个Function类，一个函数对象，并且我们只能通过`new Vue`的方式去实例化。

**为什么不适用`Class`的方式去定义Vue?**

我们可以的看到在这个文件中，我们使用了大量的Mxin的函数调用，它们的功能就是在Vue的prototype上面扩展一些方法，根据扩展的方法不同放在不同的模块中去，而不是在一个模块里面实现所有，这种方法使用Class不容易实现。模块化的目的就是为了便于管理和维护。

**initGlobalAPI**

Vue.js在整个初始化的过程中，除了给他的prototype上面扩展方法，同时对Vue这个对象本身扩展了一些必要的全局静态方法，方便直接调用使用，他的定义在`src/core/global-api/index.js`中：
```javascript
export function initGlobalAPI (Vue: GlobalAPI) {
  // config
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
    }
  }
  Object.defineProperty(Vue, 'config', configDef)

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }

  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  extend(Vue.options.components, builtInComponents)

  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
```
这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到。有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。